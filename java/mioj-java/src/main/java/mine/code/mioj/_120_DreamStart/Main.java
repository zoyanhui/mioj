package mine.code.mioj._120_DreamStart;

/**
 * - dreamstart 的催促
 * 序号：#120
 * 难度：困难
 * 时间限制：1000ms
 * 内存限制：10M
 * 描述
 * 有一天集训队的学弟们正在计算一堆数，但是 dreamstart 感觉他们算的太慢了，就让他们坐在一起想出一个快速计算的方法，但是由于他们一时想不出来，想让你帮助他们。他们说现在有一个数列，要算出第 i 个数的 i^ii
 * i
 *   次幂并且把每个数计算出来的值加到一起，最后答案模 10000019。
 *
 * 聪明的你可以帮助他们吗？
 *
 * 输入
 * 第 1 个数字为整数n，1&lt;=n&lt;=10^51<=n<=10
 * 5
 *
 *
 * 余下 n 个数，每个数的大小不超过10^{15}10
 * 15
 *
 * 输出
 * 输出取模之后的和
 *
 * 输入样例
 * 4 1 6 9 12
 * 8 1 1 1 1 1 1 1 2
 * 100 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000 1000000000000000
 *
 * 输出样例
 * 3776019   // 计算： (1 + 6**(2**2) + 9 ** (3**3) + 12 ** (4**4)) % 10000019 = 3776019
 * 2094593   // (2**(8**8) + 7) % 10000019
 * 194972
 *
 *
 *
 * 提示：欧拉定理，欧拉降幂
 * https://app.yinxiang.com/shard/s65/nl/14744105/8a3b358f-d408-4ce5-8709-2850b519f306?title=%E6%AC%A7%E6%8B%89%E9%99%8D%E5%B9%82
 * Created by zhouyanhui on 2019/12/2.
 */
import java.util.*;

public class Main {
    private static final int M = 10000019;
    public static void main(String args[]) {
        Scanner scan = new Scanner(System.in);
        String line;
        while (scan.hasNextLine()) {
            line = scan.nextLine().trim();
            long[] ints = splitToInts(line, " ");
            if(ints == null){
                System.out.println("wrong input");
                continue;
            }
            System.out.println(solution(ints));
        }
    }

    private static long solution(long[] ints) {
        long res = 0;
        int phiM = phi(M);
        for (int i = 0; i < ints.length; i++) {
            int k = i + 1;
            // 欧拉降幂
            long pow = calcPowMod(k, k, phiM);
            res = mod(res + calcPowMod(ints[i], pow, M));

        }
        return res;
    }

    private static int phi(final int m){
        int res = m, n = m;
        for (int i = 2; i <= Math.sqrt(m) + 1; i++) {
            if(n % i == 0) {
                res -= n / i;
                while (n % i == 0) {
                    n /= i;
                }
            }
        }
        if(n > 1){
            res -= res / n;
        }
        return res;
    }

    private static long mod(long n){
        if(n < 0){
            n+=M;
        }
        return n %M;
    }

    private static long calcPowMod(long base, long n, final int m) {
        long s = mod(base), res = 1;
        while(n>0){
            if((n&1) == 1){
                res = (res * s) % m;
                n--;
            }else{
                s = (s * s) % m;
                n/=2;
            }
        }
        return res;
    }

    private static long[] splitToInts(String line, String sep) {
        String[] split = line.split(sep);
        long[] ret = new long[split.length-1];
        for (int i = 1; i < split.length; i++) {
            ret[i-1] = Long.valueOf(split[i]);
        }
        if(Long.valueOf(split[0]) != ret.length){
            return null;
        }
        return ret;
    }
}

